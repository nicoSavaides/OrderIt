<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Ensure the body takes up the full viewport height */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }





    body {
      font-family: "Lora", sans-serif;
      text-align: center;
      background-color: #e9ece6;
      color: #000000;
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-sizing: border-box;
    }



    #welcomeScreen h1 {
      font-size: 4rem;
      font-weight: bold;
      line-height: .3;
    }



    #welcomeScreen p {
      font-size: 1.5rem;
      margin-top: 10px;
      line-height: 1.5;
    }


    #gameScreen h2 {
      font-size: 3rem;  /* Adjust this value as needed */
    }


    #gameScreen {
  opacity: 0;
  transition: opacity 0.5s ease-in 0.4s;
  pointer-events: none; /* Prevents accidental clicks during transition */
}

#gameScreen.visible {
  opacity: 1;
  pointer-events: auto;
}




    .hidden {
      display: none;
    }

    button {
      font-size: 1.2rem;
      background-color: #000000;
      color: #FFFFFF;
      padding: 10px 20px;
      margin-top: 150px;
      cursor: pointer;
      border-radius: 40px;
    }

    #itemList {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 150px;
      padding: 0;
      list-style: none;
    }

    @font-face {
      font-family: 'Order It.';
      src: url('orderItFont.ttf') format('truetype');
    }

    @font-face {
      font-family: 'second';
      src: url('secondFont.otf') format('truetype');
    }

    @font-face {
      font-family: 'Lora';
      src: url('Lora.ttf') format('truetype');
    }


    h1 {
      font-family: 'Order It.', sans-serif;
    }


    h2, h3 {
      font-family: 'second', sans-serif;
    }


    p {
      font-family: 'Lora', sans-serif;
    }



    .draggable-item {
      padding: 10px;
      margin: 5px;
      background-color: #CCCCCC;
      border: 1px solid #ccc;
      cursor: grab;
      font-weight: 600;
      width: 300px;
      max-width: 400px;
      box-sizing: border-box;
      text-align: center;
    }

    .drag-over {
      border: 2px dashed #333;
    }

    #gameStatus {
      position: absolute;
      top: 20%; /* Adjust this to move it up/down */
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      color: #000000;
      font-family: 'second', sans-serif;
      text-align: center;
    }

    /* DATE */
    #currentDate {
      font-size: 1rem;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
    }

    #endScreen p {
      font-size: 1.5rem;
      margin-top: 150px;
    }










        @keyframes shake {
      0% { transform: translate3d(0, 0, 0); }
      20% { transform: translate3d(-5px, 0, 0); }
      40% { transform: translate3d(5px, 0, 0); }
      60% { transform: translate3d(-5px, 0, 0); }
      80% { transform: translate3d(5px, 0, 0); }
      100% { transform: translate3d(0, 0, 0); }
    }


    .shake {
      animation: shake 0.4s ease;
    }


    @keyframes correctFlash {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

.correct-animation {
  animation: correctFlash 0.6s ease-in-out;
}








    @media (max-width: 480px) {
      /* Further adjustments for smaller screens (smartphones) */
      h1 {
        font-size: 2.9rem !important; 
        margin-top: 20px !important
      }

      h2 {
      position: fixed;
      font-size: 2.3rem !important;
      top: 46px;               /* Adjust to set how far from the top of the screen */
      left: 50%;               /* Position horizontally at the center */
      transform: translateX(-50%); /* Center it exactly by moving it back by 50% of its own width */
      text-align: center;      /* Centers text if it wraps to the next line */
      width: 100%;             /* Make sure the width is 100% of the screen width */
      box-sizing: border-box;  /* Prevents padding/margins from affecting width */
      padding: 0 23px;
      font-weight: 700;
    }



      


      p {
        padding-top: 82px !important;
        font-size: 1.03rem !important;
        font-weight: 400 !important;
        padding: 0 20px;

       }

       
      button {
        font-size: 1.5rem;
        padding: 12px 25px;
        margin-top: 25px;
      }


      .draggable-item {
        font-size: 1.5rem; /* Larger draggable items */
        width: 90%;
      }

      #strikeCount {
        position: fixed;
        font-size: 1.2rem !important;
        top: 395px; /* Set how far from the top of the screen you want it */
        left: 50%;
        transform: translateX(-50%); /* Centers the element horizontally */
        white-space: nowrap; /* Prevents the text from wrapping onto the next line */
        min-width: 200px; 
        
      }


            #submitWrapper {
        position: fixed;
        bottom: 65px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000; /* Ensure it's on top */
      }

      .submit-hit-area {
        position: relative;
        width: 100px; /* or larger to increase hit target */
        height: 60px; /* increase this for more vertical touch room */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .submit-hit-area button {
        pointer-events: auto;
        padding: 8px 16px; /* Keep visual size small */
        margin: 0;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }




        /* correct word */
      .correct-order-label {
      font-weight: 600 !important;
      
      font-size: 1.5rem !important;
      text-align: center;
      margin-top: 68px !important; /* Use margin to position it vertically */
      }

      
      .correct-order-tile {
      font-weight: 650 !important;
      position: relative;
      top: -135px !important;             /* Adjust vertical position as needed */
      transition: transform 0.3s ease;
      z-index: 1;             /* Ensure it's on top of other elements */
    }


    
    #itemListWrapper {
    position: absolute;  /* Use absolute positioning to ensure it is centered */
    top: 65px;
    left: 50%;
    transform: translateX(-50%);  /* Center the element */
    width: 90%;  /* Ensure it doesn't stretch beyond the screen width */
    z-index: 10;  /* Ensure it's above other content */
    box-sizing: border-box;  /* Prevent padding/margins from affecting width */
    will-change: transform; /* Optimize for mobile */
  }








  #endGameStatus {
      font-size: 3.5rem !important; /* Adjust this size as needed for mobile */
      font-family: 'second' !important;
      /*font-weight: bold;*/
      color: #000;
      text-align: center;
      margin-top: 9px !important;
    }

      #finalScore {
        margin-top: -135px !important;
        font-size: 1.2rem !important;
      }

      #thanksMessage {
        
      position: relative;
      top: -130px !important;
      text-align: center;
      font-size: 1.2rem !important;
    }


    #shareLink,
#shareButton {
  position: relative;
  z-index: 1;
  margin-top: 2px !important; /* Keep your margin-top */
}

#shareLink::after,
#shareButton::after {
  content: '';
  position: absolute;
  top: -10px; /* Adjust to expand clickable area vertically */
  left: -10px; /* Adjust to expand clickable area horizontally */
  right: -10px;
  bottom: -10px;
  z-index: -1; /* Invisible expanded clickable area */
}


      

    
      #currentDate {
  position: fixed; 
  bottom: 6px !important; /* Lower value pushes it closer to the bottom */
  font-size: 0.9rem !important;
}
 
}




    /* GIF */
    .mobile-logo {
      margin-top: 17px !important;
      width: 200px; /* Default size */
      height: 100px; /* Default size */
      margin-left: 11px;
      
}



#gameStatus {
  display: block !important;
}






  </style>
</head>
<body>
  <!-- Your body content here -->
</body>


  <div id="welcomeScreen">
    <div>

      <img src="movingLogo.gif" alt="Moving Logo" class="mobile-logo">



      <h1>Order It.</h1>
      <p>Drag the items into the correct order based on the given category. The item with the lowest value (smallest, shortest, lightest, etc.) should go at the top. 
        The item with the highest value (largest, tallest, heaviest, etc.) should go at the bottom. 3 rounds. 3 mistakes allowed.</p>
      <button onclick="startGame()">Play</button>
    </div>
  </div>







  <div id="gameScreen" class="hidden">
    <h2 id="roundPrompt"></h2>
    <p id="gameStatus"></p>

    <div id="itemListWrapper">
    <ul id="itemList"></ul>
  </div>

  

    <p id="strikeCount"></p>
    

    <div id="submitWrapper"> 
      <div class="touch-buffer">
        <button onclick="submitOrder()">Submit</button>
      </div>
    </div>


    
    

   
   
  </div>
  
  <div id="endScreen" class="hidden">
    <p id="endGameStatus"></p>
    <p id="finalScore"></p> <!-- their score will appear here -->
    <p id="thanksMessage">Thanks for playing. Come back tomorrow for a new Order It!</p>
    <button id="shareButton">Share your score</button> <!-- share button -->
    <p id="shareLink" style="word-break: normal; font-size: 1.2em; margin-top: 10px;"></p>

  </div>
  
  <p id="currentDate"></p>
  
  <script>
    let currentRound = 0;
    let rounds = [];
    let strikes = 0;
    const maxStrikes = 3;







    function startGame() {
  document.getElementById('welcomeScreen').classList.add('hidden');

  const gameScreen = document.getElementById('gameScreen');
  gameScreen.classList.remove('hidden');

  // Ensure the screen is only faded in after layout
  requestAnimationFrame(() => {
    gameScreen.classList.add('visible');
  });

  fetch("rounds.json")
    .then(res => res.json())
    .then(data => {
      const dayIndex = 0;
      rounds = data.days[dayIndex];
      loadRound();
    })
    .catch(error => {
      console.error("Error loading rounds data:", error);
    });
}










  
    function displayCurrentDate() {
      const now = new Date();
      const options = { year: 'numeric', month: 'long', day: 'numeric' };
      const formattedDate = now.toLocaleDateString(undefined, options);
      document.getElementById('currentDate').textContent = `${formattedDate}`;
    }
  
    displayCurrentDate();
  
    function loadRound() {
      if (currentRound >= rounds.length) {
        endGame();
        return;
      }

      
      const { prompt, items } = rounds[currentRound];
      document.getElementById('roundPrompt').textContent = "Order by: " + prompt;
  
      const itemList = document.getElementById('itemList');
  
      if (currentRound === 0) {
        items.forEach(item => {
          const li = document.createElement('li');
          li.textContent = item;
          li.setAttribute('draggable', true);
          li.classList.add('draggable-item');
          itemList.appendChild(li);
        });
      }
  
      updateStrikes();
      makeItemsDraggable();
    }
























  function makeItemsDraggable() {
  let hasMoved = false;

  const items = document.querySelectorAll('.draggable-item');
  let draggedItem = null;
  let draggedItemInitialPosition = { x: 0, y: 0 };
  let offsetX = 0;
  let offsetY = 0;

  // Desktop drag & drop
  items.forEach(item => {
    item.setAttribute('draggable', true);

    item.addEventListener('dragstart', (e) => {
      draggedItem = item;
      draggedItem.classList.add('dragging');
      setTimeout(() => {
        draggedItem.style.opacity = '0.5';
      }, 0);
    });

    item.addEventListener('dragend', () => {
      draggedItem.style.opacity = '';
      draggedItem.classList.remove('dragging');
      draggedItem = null;
    });

    item.addEventListener('dragover', (e) => e.preventDefault());
    item.addEventListener('dragenter', (e) => e.preventDefault());

    item.addEventListener('drop', () => {
      if (draggedItem && draggedItem !== item) {
        const list = item.parentNode;
        const draggedIndex = Array.from(list.children).indexOf(draggedItem);
        const targetIndex = Array.from(list.children).indexOf(item);

        if (draggedIndex < targetIndex) {
          list.insertBefore(draggedItem, item.nextSibling);
        } else {
          list.insertBefore(draggedItem, item);
        }
      }
    });
  });

  // Mobile touch
  items.forEach(item => {
    item.addEventListener('touchstart', (e) => {
      hasMoved = false;

      e.preventDefault();
      draggedItem = item;
      draggedItemInitialPosition = {
        x: e.touches[0].pageX,
        y: e.touches[0].pageY
      };
      draggedItem.classList.add('dragging');
      draggedItem.style.transition = 'none';
      draggedItem.style.zIndex = '1000';
      draggedItem.style.opacity = '0.5';
    });

    item.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
const dx = touch.pageX - draggedItemInitialPosition.x;
const dy = touch.pageY - draggedItemInitialPosition.y;

if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
  hasMoved = true;
}

      
      offsetX = touch.pageX - draggedItemInitialPosition.x;
      offsetY = touch.pageY - draggedItemInitialPosition.y;
      draggedItem.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    });






item.addEventListener('touchend', (e) => {
  // Reset visuals

  if (!hasMoved) {
  // It's a tap, not a drag — just reset and exit
  draggedItem.classList.remove('dragging');
  draggedItem.style.transform = '';
  draggedItem.style.transition = '';
  draggedItem.style.opacity = '';
  draggedItem.style.zIndex = '';
  draggedItem = null;
  return;
}

  draggedItem.style.transform = '';
  draggedItem.style.transition = '';
  draggedItem.style.opacity = '';
  draggedItem.style.zIndex = '';

  const touch = e.changedTouches[0];
  const list = draggedItem.parentNode;
  const itemsArray = Array.from(list.children);

  let targetItem = null;

  // Start scan from 0 to ±50px to prioritize closest elements
  const scanOffsets = [];
  for (let i = 0; i <= 50; i += 5) {
    scanOffsets.push(i, -i); // [0, -0, 5, -5, 10, -10, ...]
  }

  for (const offset of scanOffsets) {
    // Temporarily hide draggedItem for detection
    draggedItem.style.visibility = 'hidden';
    const el = document.elementFromPoint(touch.clientX, touch.clientY + offset);
    draggedItem.style.visibility = 'visible';

    if (!el) continue;
    const candidate = el.closest('.draggable-item');
    if (candidate && candidate !== draggedItem) {
      targetItem = candidate;
      break;
    }
  }

  if (targetItem) {
    const draggedIndex = itemsArray.indexOf(draggedItem);
    const targetIndex = itemsArray.indexOf(targetItem);

    if (draggedIndex < targetIndex) {
      list.insertBefore(draggedItem, targetItem.nextSibling);
    } else {
      list.insertBefore(draggedItem, targetItem);
    }
  }

  draggedItem.classList.remove('dragging');
  draggedItem = null;
});


  });
}

























let roundsCompleted = 0; // Track how many rounds the player has completed successfully.

function submitOrder() {
  const itemList = document.getElementById('itemList');
  const submittedOrder = Array.from(itemList.children).map(li => li.textContent);
  const correctOrder = rounds[currentRound].correctOrder;

  if (JSON.stringify(submittedOrder) === JSON.stringify(correctOrder)) {
    roundsCompleted++; // Increment rounds completed on correct order.
    currentRound++;

    itemList.classList.add('correct-animation'); // Add the animation class

// Remove the animation class after 600ms (duration of animation)
    setTimeout(() => {
      itemList.classList.remove('correct-animation');
    }, 900); 


    if (currentRound < rounds.length) {
      loadRound();
    } else {
      // If all rounds are completed without exceeding max strikes
      if (strikes < maxStrikes) {
        setTimeout(endGame, 500); // Wait for a moment, then end the game
      } else {
        document.getElementById('gameStatus').textContent = "Nice!"; // Fallback message if there are strikes
      }
    }
  } else {
      strikes++;
      updateStrikes();

  


const itemList = document.getElementById('itemList');
itemList.classList.add('shake');


itemList.offsetHeight;  


setTimeout(() => {
  itemList.classList.remove('shake');
}, 400);














    if (strikes >= maxStrikes) {
      const strikeCountEl = document.getElementById('strikeCount'); // This is the element showing "Mistakes Remaining"
      if (strikeCountEl) {
        strikeCountEl.style.display = 'none'; // This hides the text element
      }









      const itemList = document.getElementById('itemList');
      itemList.innerHTML = '';

      // Create the label and add the class instead of inline styles
      const label = document.createElement('p');
      label.textContent = 'Correct Order:';
      label.classList.add('correct-order-label');  // Add the CSS class here






      itemList.parentNode.insertBefore(label, itemList);

      correctOrder.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        li.classList.add('draggable-item');
        li.classList.add('correct-order-tile');
        li.style.backgroundColor = '#999999';
        li.style.fontWeight = 'bold';
        li.style.cursor = 'default';
        li.setAttribute('draggable', false);
        itemList.appendChild(li);
      });

      document.querySelector("button[onclick='submitOrder()']").disabled = true;
      document.getElementById("submitWrapper").style.display = "none";


      setTimeout(() => {
        label.remove();
        endGame();
      }, 5000);
    }
  }
}


  
    function updateStrikes() {
      document.getElementById('strikeCount').textContent = `Mistakes Remaining: ${maxStrikes - strikes}`;

    }








    
    let score = 0; // you should already be tracking this
   


    function endGame() {
  console.log("End game triggered");  // Test if this is being reached
  document.getElementById('gameScreen').classList.add('hidden'); // Hide the game screen
  document.getElementById('endScreen').classList.remove('hidden'); // Show the end screen

  let message = "";  // Default message

  // Set message based on the rounds completed
  if (roundsCompleted === 3) {
    message = "Amazing!";
  } else if (roundsCompleted === 2) {
    message = "Good job!";
  } else if (roundsCompleted === 1) {
    message = "Not bad!";
  } else {
    message = "Nice try";
  }

  // Update the end game status message
  document.getElementById('endGameStatus').textContent = message;

  // Show the player's final score
  document.getElementById('finalScore').textContent = `You scored ${roundsCompleted} out of ${rounds.length}`;

  // Set up the share button
  const shareButton = document.getElementById('shareButton');
  shareButton.onclick = function() {
    generateShareLink();
  };
}







function generateShareLink(roundsCompleted) {
  // Get the emoji score based on the rounds completed
  const emojiScore = getEmojiScore(roundsCompleted);

  // Create the shareable URL with the emoji score as a query parameter
  const baseUrl = window.location.origin + window.location.pathname; // Current page URL
  const shareUrl = `${baseUrl}?score=${emojiScore}`;

  // Set the inner HTML of the shareLink element to show the link with emoji score
  const shareLink = document.getElementById('shareLink');
  shareLink.innerHTML = `<a href="${shareUrl}" target="_blank">Order It ${emojiScore}</a>`;
}







function getEmojiScore(roundsCompleted) {
  const maxRounds = 3; 
  let score = '';

  if (roundsCompleted == 0) {
    score = '⬛⬛⬛'; 
  } else if (roundsCompleted == 1) {
    score = '🟩⬛⬛'; 
  } else if (roundsCompleted == 2) {
    score = '🟩🟩⬛'; 
  } else if (roundsCompleted == 3) {
    score = '🟩🟩🟩'; 
  }

  return score;
}










const shareButton = document.getElementById('shareButton');

shareButton.addEventListener('click', () => {

  
  
  // Use the getEmojiScore function to get the emoji score
  const emojiScore = getEmojiScore(roundsCompleted);
  
  const correctCount = roundsCompleted; // Assuming `roundsCompleted` equals the number of correct answers
  const total = 3; // This can be dynamic if the total number of rounds is variable

  let text; // Declare `text` here

  if (roundsCompleted == 3) {
  if (strikes == 1) {
    text = `${emojiScore}\n${roundsCompleted}/3 rounds\n${strikes} mistake`;
  } else {
    text = `${emojiScore}\n${roundsCompleted}/3 rounds\n${strikes} mistakes`;
  }
} else {
  text = `${emojiScore}`;
}



  const shareData = {
    title: 'Order It',
    text: text,
    url: window.location.href
  };

  // Trigger the share functionality (this depends on your environment, e.g., for web sharing)
  if (navigator.share) {
    navigator.share(shareData)
      .then(() => console.log('Share successful!'))
      .catch((error) => console.log('Error sharing:', error));
  } else {
    // Fallback if Web Share API is not supported
    console.log('Web Share API not supported. Sharing manually via text:');
    console.log(text);
  }
});











   
  </script>

</body>
</html>
