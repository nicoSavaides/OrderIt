<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Ensure the body takes up the full viewport height */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }





    body {
      font-family: "Lora", sans-serif;
      text-align: center;
      background-color: #e9ece6;
      color: #000000;
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-sizing: border-box;
    }



    #welcomeScreen h1 {
      font-size: 4rem;
      font-weight: bold;
      line-height: .3;
    }



    #welcomeScreen p {
      font-size: 1.5rem;
      margin-top: 10px;
      line-height: 1.5;
    }


    #gameScreen h2 {
      font-size: 3rem;  /* Adjust this value as needed */
    }


    #gameScreen {
  opacity: 0;
  transition: opacity 0.5s ease-in 0.4s;
  pointer-events: none; /* Prevents accidental clicks during transition */
}

#gameScreen.visible {
  opacity: 1;
  pointer-events: auto;
}




    .hidden {
      display: none;
    }

    button {
      font-size: 1.2rem;
      background-color: #000000;
      color: #FFFFFF;
      padding: 10px 20px;
      margin-top: 150px;
      cursor: pointer;
      border-radius: 40px;
    }

    #itemList {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 150px;
      padding: 0;
      list-style: none;
    }

    @font-face {
      font-family: 'Order It.';
      src: url('orderItFont.ttf') format('truetype');
    }

    @font-face {
      font-family: 'second';
      src: url('secondFont.otf') format('truetype');
    }

    @font-face {
      font-family: 'Lora';
      src: url('Lora.ttf') format('truetype');
    }


    h1 {
      font-family: 'Order It.', sans-serif;
    }


    h2, h3 {
      font-family: 'second', sans-serif;
    }


    p {
      font-family: 'Lora', sans-serif;
    }



    .draggable-item {
      padding: 10px;
      margin: 5px;
      background-color: #CCCCCC;
      border: 1px solid #ccc;
      cursor: grab;
      font-weight: 700;
      width: 300px;
      max-width: 400px;
      box-sizing: border-box;
      text-align: center;
    }

    .drag-over {
      border: 2px dashed #333;
    }

    #gameStatus {
      position: absolute;
      top: 20%; /* Adjust this to move it up/down */
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      color: #000000;
      font-family: 'second', sans-serif;
      text-align: center;
    }

    /* DATE */
    #currentDate {
      font-size: 1rem;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
    }

    #endScreen p {
      font-size: 1.5rem;
      margin-top: 150px;
    }











        @keyframes shake {
      0% { transform: translateX(0); }
      20% { transform: translateX(-3px); }
      40% { transform: translateX(3px); }
      60% { transform: translateX(-3px); }
      80% { transform: translateX(3px); }
      100% { transform: translateX(0); }
    }

    .shake {
      animation: shake 0.4s ease;
    }








    @media (max-width: 480px) {
      /* Further adjustments for smaller screens (smartphones) */
      h1 {
        font-size: 2.9rem !important; 
        margin-top: 20px !important
      }

      h2 {
      position: fixed;
      font-size: 2.3rem !important;
      top: 30px;               /* Adjust to set how far from the top of the screen */
      left: 50%;               /* Position horizontally at the center */
      transform: translateX(-50%); /* Center it exactly by moving it back by 50% of its own width */
      text-align: center;      /* Centers text if it wraps to the next line */
      width: 100%;             /* Make sure the width is 100% of the screen width */
      box-sizing: border-box;  /* Prevents padding/margins from affecting width */
      padding: 0 23px;
    }



      p {
        padding-top: 82px !important;
        font-size: 1.03rem !important;
        font-weight: 400 !important;
        padding: 0 20px;

       }

       

      button {
        font-size: 1.5rem;
        padding: 12px 25px;
        margin-top: 21px;
      }





      .draggable-item {
        font-size: 1.5rem; /* Larger draggable items */
        width: 90%;
      }

      #strikeCount {
        position: fixed;
        font-size: 1.2rem !important;
        top: 379px; /* Set how far from the top of the screen you want it */
        left: 50%;
        transform: translateX(-50%); /* Centers the element horizontally */
        white-space: nowrap; /* Prevents the text from wrapping onto the next line */
        min-width: 200px; 
        
      }


      #submitWrapper {
      position: fixed;  /* Fix the element's position relative to the viewport */
      bottom: 67px;     /* Position it 20px from the bottom of the screen */
      left: 50%;        /* Center it horizontally */
      transform: translateX(-50%); /* Ensure it's centered */
      padding: 12px 25px; /* Increase padding for better touch targets */
    }


      #submitWrapper button {
      margin-top: 0; /* Remove the big margin that button normally has */
      }



        /* correct word */
      .correct-order-label {
       
      font-weight: bold;
      font-size: 1.5rem !important;
      text-align: center;
      margin-top: 73px !important; /* Use margin to position it vertically */
      }

      
      .correct-order-tile {
      
      top: 100px;             /* Adjust vertical position as needed */
      transition: transform 0.3s ease;
      z-index: 1;             /* Ensure it's on top of other elements */
    }



    


    
  #itemList {
    position: absolute;  /* Use absolute positioning to ensure it is centered */
    top: 60px;
    left: 50%;
    transform: translateX(-50%);  /* Center the element */
    width: 90%;  /* Ensure it doesn't stretch beyond the screen width */
    z-index: 10;  /* Ensure it's above other content */
    box-sizing: border-box;  /* Prevent padding/margins from affecting width */
    will-change: transform; /* Optimize for mobile */
  }




      #endGameStatus {
      font-size: 3.5rem !important; /* Adjust this size as needed for mobile */
      font-family: 'second' !important;
      /*font-weight: bold;*/
      color: #000;
      text-align: center;
      margin-top: 10px !important;
    }

      #finalScore {
        margin-top: -140px !important;
        font-size: 1.2rem !important;
      }

      #thanksMessage {
        
      position: relative;
      top: -130px !important;
      text-align: center;
      font-size: 1.2rem !important;
    }



      #shareLink,
      #shareButton {
        margin-top: 5px !important;
      }


      


      #currentDate {
  position: fixed; 
  bottom: 6px !important; /* Lower value pushes it closer to the bottom */
  font-size: 0.9rem !important;
}

 
  



    }


    /* GIF */
    .mobile-logo {
      margin-top: 17px !important;
      width: 200px; /* Default size */
      height: 100px; /* Default size */
      margin-left: 11px;
      
    
}





#gameStatus {
  display: block !important;
}











    





  </style>
</head>
<body>
  <!-- Your body content here -->
</body>


  <div id="welcomeScreen">
    <div>

      <img src="movingLogo.gif" alt="Moving Logo" class="mobile-logo">



      <h1>Order It.</h1>
      <p>Drag the items into the correct order based on the given category. The item with the lowest value (smallest, shortest, lightest, etc.) should go at the top. 
        The item with the highest value (largest, tallest, heaviest, etc.) should go at the bottom. 3 rounds. 3 mistakes allowed.</p>
      <button onclick="startGame()">Play</button>
    </div>
  </div>












  <div id="gameScreen" class="hidden">
    <h2 id="roundPrompt"></h2>
    <p id="gameStatus"></p>
    <ul id="itemList"></ul>

    <p id="strikeCount"></p>
    

    <div id="submitWrapper">
      <button onclick="submitOrder()">Submit</button>
    </div>

   
   
  </div>
  
  <div id="endScreen" class="hidden">
    <p id="endGameStatus"></p>
    <p id="finalScore"></p> <!-- their score will appear here -->
    <p id="thanksMessage">Thanks for playing. Come back tomorrow for a new Order It!</p>
    <button id="shareButton">Share your score</button> <!-- share button -->
    <p id="shareLink" style="word-break: break-all;"></p> <!-- link will show up here -->
  </div>
  
  <p id="currentDate"></p>
  
  <script>
    let currentRound = 0;
    let rounds = [];
    let strikes = 0;
    const maxStrikes = 3;







    function startGame() {
  document.getElementById('welcomeScreen').classList.add('hidden');

  const gameScreen = document.getElementById('gameScreen');
  gameScreen.classList.remove('hidden');

  // Ensure the screen is only faded in after layout
  requestAnimationFrame(() => {
    gameScreen.classList.add('visible');
  });

  fetch("rounds.json")
    .then(res => res.json())
    .then(data => {
      const dayIndex = 24;
      rounds = data.days[dayIndex];
      loadRound();
    })
    .catch(error => {
      console.error("Error loading rounds data:", error);
    });
}










  
    function displayCurrentDate() {
      const now = new Date();
      const options = { year: 'numeric', month: 'long', day: 'numeric' };
      const formattedDate = now.toLocaleDateString(undefined, options);
      document.getElementById('currentDate').textContent = `${formattedDate}`;
    }
  
    displayCurrentDate();
  
    function loadRound() {
      if (currentRound >= rounds.length) {
        endGame();
        return;
      }
  
      
      
      
      
      
      
      
      
      const { prompt, items } = rounds[currentRound];
      document.getElementById('roundPrompt').textContent = "Order by: " + prompt;
  
      const itemList = document.getElementById('itemList');
  
      if (currentRound === 0) {
        items.forEach(item => {
          const li = document.createElement('li');
          li.textContent = item;
          li.setAttribute('draggable', true);
          li.classList.add('draggable-item');
          itemList.appendChild(li);
        });
      }
  
      updateStrikes();
      makeItemsDraggable();
    }



    function makeItemsDraggable() {
  const items = document.querySelectorAll('.draggable-item');
  let draggedItem = null;
  let draggedItemInitialPosition = { x: 0, y: 0 };
  let offsetX = 0;
  let offsetY = 0;

  // Desktop (Mouse) Events
  items.forEach(item => {
    item.addEventListener('dragstart', (e) => {
      draggedItem = item;
      draggedItemInitialPosition = { x: e.pageX, y: e.pageY };

      // Add class for visual feedback and make it semi-transparent
      draggedItem.classList.add('dragging');
      setTimeout(() => {
        draggedItem.style.opacity = '0.5'; // Make the dragged item semi-transparent
      }, 0);
    });

    item.addEventListener('dragover', (e) => {
      e.preventDefault();  // Allow the tile to be dropped, but do not change position during drag
    });

    item.addEventListener('dragenter', (e) => {
      e.preventDefault();  // Allow the hover effect to apply
    });

    item.addEventListener('dragend', () => {
      // Reset after drag ends
      draggedItem.style.opacity = ''; // Reset opacity
      draggedItem.classList.remove('dragging'); // Remove dragging class
      draggedItem = null; // Clear reference to the dragged item
    });

    item.addEventListener('drop', () => {
      // Reorder the tiles only after the item is dropped
      if (draggedItem !== item) {
        const list = item.parentNode;
        const draggedIndex = Array.from(list.children).indexOf(draggedItem);
        const droppedIndex = Array.from(list.children).indexOf(item);

        // Only reorder after the item is dropped
        if (draggedIndex < droppedIndex) {
          list.insertBefore(draggedItem, item.nextSibling);
        } else {
          list.insertBefore(draggedItem, item);
        }
      }

      // Reset dragged item after drop
      draggedItem.style.opacity = '';
      draggedItem.classList.remove('dragging');
      draggedItem = null;
    });
  });

  // Mobile (Touch) Events
  items.forEach(item => {
    item.addEventListener('touchstart', (e) => {
      e.preventDefault();  // Prevent default touch behavior
      draggedItem = item;
      draggedItemInitialPosition = {
        x: e.touches[0].pageX,
        y: e.touches[0].pageY,
      };

      // Add class for visual feedback
      draggedItem.classList.add('dragging');
      setTimeout(() => {
        draggedItem.style.opacity = '0.5'; // Make the dragged item semi-transparent
      }, 0);
    });

    item.addEventListener('touchmove', (e) => {
      e.preventDefault();  // Prevent default touch behavior

      // Calculate how far the touch has moved
      const touch = e.touches[0];
      offsetX = touch.pageX - draggedItemInitialPosition.x;
      offsetY = touch.pageY - draggedItemInitialPosition.y;

      // Update the position of the dragged item
      draggedItem.style.position = 'absolute';
        draggedItem.style.left = `${touch.pageX - draggedItem.offsetWidth / 2}px`; // Center the item on the touch
        draggedItem.style.top = `${touch.pageY - draggedItem.offsetHeight / 2}px`;
    });

    item.addEventListener('touchend', (e) => {
        // After touch ends, reset the position
        draggedItem.style.position = ''; // Reset position
        draggedItem.style.left = ''; // Reset left position
        draggedItem.style.top = ''; // Reset top position
        draggedItem.style.opacity = ''; // Reset opacity

      // Check where the item should be placed and reorder
      const allItems = Array.from(document.querySelectorAll('.draggable-item'));
      allItems.forEach((otherItem) => {
        if (otherItem === draggedItem) return;

        const rect = otherItem.getBoundingClientRect();
        if (e.changedTouches[0].pageY > rect.top && e.changedTouches[0].pageY < rect.bottom) {
          const list = draggedItem.parentNode;
          const draggedIndex = Array.from(list.children).indexOf(draggedItem);
          const droppedIndex = Array.from(list.children).indexOf(otherItem);

          // Reorder only after dropping the dragged item
          if (draggedIndex < droppedIndex) {
            list.insertBefore(draggedItem, otherItem.nextSibling);
          } else {
            list.insertBefore(draggedItem, otherItem);
          }
        }
      });

      // Reset dragged item state
      draggedItem.classList.remove('dragging');
      draggedItem = null;
    });

    item.addEventListener('touchcancel', () => {
      draggedItem.style.transform = ''; // Reset position if canceled
      draggedItem.style.position = ''; // Reset positioning if canceled
      draggedItem.style.opacity = ''; // Reset opacity if canceled
      draggedItem.classList.remove('dragging'); // Remove dragging class
      draggedItem = null;
    });
  });
}





let roundsCompleted = 0; // Track how many rounds the player has completed successfully.

function submitOrder() {
  const itemList = document.getElementById('itemList');
  const submittedOrder = Array.from(itemList.children).map(li => li.textContent);
  const correctOrder = rounds[currentRound].correctOrder;

  if (JSON.stringify(submittedOrder) === JSON.stringify(correctOrder)) {
    roundsCompleted++; // Increment rounds completed on correct order.
    currentRound++;
    if (currentRound < rounds.length) {
      loadRound();
    } else {
      // If all rounds are completed without exceeding max strikes
      if (strikes < maxStrikes) {
        setTimeout(endGame, 500); // Wait for a moment, then end the game
      } else {
        document.getElementById('gameStatus').textContent = "Nice!"; // Fallback message if there are strikes
      }
    }
  } else {
      strikes++;
      updateStrikes();

  

// Add the shake effect to the item list
const itemList = document.getElementById('itemList');
itemList.classList.add('shake');

// Force reflow to ensure the animation is applied correctly
itemList.offsetHeight;  // Reading a property forces a reflow

// Remove the shake class after animation ends so it can be triggered again
setTimeout(() => {
  itemList.classList.remove('shake');
}, 400);














    if (strikes >= maxStrikes) {
      const strikeCountEl = document.getElementById('strikeCount'); // This is the element showing "Mistakes Remaining"
      if (strikeCountEl) {
        strikeCountEl.style.display = 'none'; // This hides the text element
      }









      const itemList = document.getElementById('itemList');
      itemList.innerHTML = '';

      // Create the label and add the class instead of inline styles
      const label = document.createElement('p');
      label.textContent = 'Correct Order:';
      label.classList.add('correct-order-label');  // Add the CSS class here






      itemList.parentNode.insertBefore(label, itemList);

      correctOrder.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        li.classList.add('draggable-item');
        li.classList.add('correct-order-tile');
        li.style.backgroundColor = '#777777';
        li.style.fontWeight = 'bold';
        li.style.cursor = 'default';
        li.setAttribute('draggable', false);
        itemList.appendChild(li);
      });

      document.querySelector("button[onclick='submitOrder()']").disabled = true;
      document.getElementById("submitWrapper").style.display = "none";


      setTimeout(() => {
        label.remove();
        endGame();
      }, 5000);
    }
  }
}


  
    function updateStrikes() {
      document.getElementById('strikeCount').textContent = `Mistakes Remaining: ${maxStrikes - strikes}`;

    }








    
    let score = 0; // you should already be tracking this
   


    function endGame() {
  console.log("End game triggered");  // Test if this is being reached
  document.getElementById('gameScreen').classList.add('hidden'); // Hide the game screen
  document.getElementById('endScreen').classList.remove('hidden'); // Show the end screen

  let message = "";  // Default message

  // Set message based on the rounds completed
  if (roundsCompleted === 3) {
    message = "Amazing!";
  } else if (roundsCompleted === 2) {
    message = "Good job!";
  } else if (roundsCompleted === 1) {
    message = "Not bad";
  } else {
    message = "Nice try";
  }

  // Update the end game status message
  document.getElementById('endGameStatus').textContent = message;

  // Show the player's final score
  document.getElementById('finalScore').textContent = `You scored ${roundsCompleted} out of ${rounds.length}`;

  // Set up the share button
  const shareButton = document.getElementById('shareButton');
  shareButton.onclick = function() {
    generateShareLink();
  };
}









function generateShareLink() {
  // Create a simple shareable link with score in the URL
  const baseUrl = window.location.origin + window.location.pathname; // current page
  const shareUrl = `${baseUrl}?score=${score}`;

  const shareLink = document.getElementById('shareLink');
  shareLink.innerHTML = `<a href="${shareUrl}" target="_blank">${shareUrl}</a>`;

  // Optionally, automatically copy to clipboard:
  navigator.clipboard.writeText(shareUrl).then(() => {
    alert('Link copied to clipboard!');
  });
}

// If you want, you can ALSO read the ?score= part of URL and display it when someone clicks a shared link!
window.onload = function() {
  const urlParams = new URLSearchParams(window.location.search);
  const sharedScore = urlParams.get('score');
  if (sharedScore !== null) {
    alert(`Your friend's score: ${sharedScore}/3`);
  }
};




   
  </script>

</body>
</html>
