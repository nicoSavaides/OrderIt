<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Ensure the body takes up the full viewport height */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }





    body {
      font-family: "Lora", sans-serif;
      text-align: center;
      background-color: #e9ece6;
      color: #000000;
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-sizing: border-box;
    }

    body, #welcomeScreen, #gameScreen, #endScreen {
  touch-action: none;
}



    #welcomeScreen h1 {
      font-size: 4rem;
      font-weight: bold;
      line-height: .3;
    }



    #welcomeScreen p {
      font-size: 1.5rem;
      margin-top: 10px;
      line-height: 1.5;
    }


    #gameScreen h2 {
      font-size: 3rem;  /* Adjust this value as needed */
    }


    #gameScreen {
  opacity: 0;
  transition: opacity 0.5s ease-in 0.4s;
  pointer-events: none; /* Prevents accidental clicks during transition */
}

#gameScreen.visible {
  opacity: 1;
  pointer-events: auto;
}




    .hidden {
      display: none !important;
    }

    button {
      font-size: 1.2rem;
      background-color: #000000;
      color: #FFFFFF;
      padding: 10px 20px;
      margin-top: 150px;
      cursor: pointer;
      border-radius: 40px;
    }

    #itemList {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 150px;
      padding: 0;
      list-style: none;
    }

    @font-face {
      font-family: 'Order It.';
      src: url('orderItFont.ttf') format('truetype');
    }

    @font-face {
      font-family: 'second';
      src: url('secondFont.otf') format('truetype');
    }

    @font-face {
      font-family: 'Lora';
      src: url('Lora.ttf') format('truetype');
    }


    h1 {
      font-family: 'Order It.', sans-serif;
    }


    h2, h3 {
      font-family: 'second', sans-serif;
    }


    p {
      font-family: 'Lora', sans-serif;
    }



    .draggable-item {
      padding: 10px;
      margin: 5px;
      background-color: #D8D8D8;
      border: 1px solid #ccc;
      cursor: grab;
      font-weight: 600;
      width: 300px;
      max-width: 400px;
      box-sizing: border-box;
      text-align: center;
    }

    .drag-over {
      border: 2px dashed #333;
    }

    #gameStatus {
      position: absolute;
      top: 20%; /* Adjust this to move it up/down */
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      color: #000000;
      font-family: 'second', sans-serif;
      text-align: center;
    }

    /* DATE */
    #currentDate {
      font-size: 1rem;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
    }

    #endScreen p {
      font-size: 1.5rem;
      margin-top: 150px;
    }










        @keyframes shake {
      0% { transform: translate3d(0, 0, 0); }
      20% { transform: translate3d(-5px, 0, 0); }
      40% { transform: translate3d(5px, 0, 0); }
      60% { transform: translate3d(-5px, 0, 0); }
      80% { transform: translate3d(5px, 0, 0); }
      100% { transform: translate3d(0, 0, 0); }
    }


    .shake {
      animation: shake 0.4s ease;
    }


    @keyframes correctFlash {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.10);
  }
  100% {
    transform: scale(1);
  }
}

.correct-animation {
  animation: correctFlash 0.6s ease-in-out;
}



/* already played already played  already played  already played  already played  already played  already played  already played  already played  */






#playedTodayScreen p {
  font-size: 2em !important;
  font-weight: bold;
  margin-bottom: 10px;
}

#playedTodayScreen button {
  font-size: 1.5em;
  padding: 12px 25px;
  position: relative;
  z-index: 1;
  margin-top: 10px;
}

#viewStatsButton {
  display: block;
  margin: 10px auto;
  z-index: 999;
  position: relative; /* Add this if missing */
}







/* Todays Answers   Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers */

#playedRounds {
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  gap: 30px; /* Space between each round */
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

.round-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}


.round-heading {
  font-size: 1.2em;
  margin-bottom: 10px;
}

.round-list {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center; /* This centers the items horizontally */
}


.round-item {
  background: #f0f0f0;
  padding: 8px 12px;
  border-radius: 6px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);

}





#currentRound {
  position: fixed; 
  bottom: 10px !important; /* Lower value pushes it closer to the bottom */
  left: 50%;               /* Position horizontally at the center */
  transform: translateX(-50%); 
  font-size: 1rem !important;
}




    @media (max-width: 480px) {
      /* Further adjustments for smaller screens (smartphones) */
      h1 {
        font-size: 2.9rem !important; 
        margin-top: 22px !important
      }

      h2 {
      position: fixed;
      font-size: 2.3rem !important;
      top: 46px;               /* Adjust to set how far from the top of the screen */
      left: 50%;               /* Position horizontally at the center */
      transform: translateX(-50%); /* Center it exactly by moving it back by 50% of its own width */
      text-align: center;      /* Centers text if it wraps to the next line */
      width: 100%;             /* Make sure the width is 100% of the screen width */
      box-sizing: border-box;  /* Prevents padding/margins from affecting width */
      padding: 0 23px;
      font-weight: 700;
    }



      


      p {
        padding-top: 77px !important;
        font-size: 1.03rem !important;
        font-weight: 400 !important;
        padding: 0 20px;

       }

       
      button {
        font-size: 1.5rem;
        padding: 12px 25px;
        margin-top: 27px;
      }


      .draggable-item {
      will-change: transform;
      transform: translateZ(0);       /* Forces GPU layer */
      backface-visibility: hidden;    /* Avoids flickering/glitches */

      transform-style: preserve-3d;
      
      font-size: 1.5rem;
      width: 90%;
    }


      #strikeCount {
        position: fixed;
        font-size: 1.2rem !important;
        top: 395px; /* Set how far from the top of the screen you want it */
        left: 50%;
        transform: translateX(-50%); /* Centers the element horizontally */
        white-space: nowrap; /* Prevents the text from wrapping onto the next line */
        min-width: 200px; 
        
      }


            #submitWrapper {
        position: fixed;
        bottom: 72px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000; /* Ensure it's on top */
      }

      .submit-hit-area {
        position: relative;
        width: 100px; /* or larger to increase hit target */
        height: 60px; /* increase this for more vertical touch room */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .submit-hit-area button {
        pointer-events: auto;
        padding: 8px 16px; /* Keep visual size small */
        margin: 0;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }




        /* correct word */
      .correct-order-label {
      font-weight: 600 !important;
      
      font-size: 1.5rem !important;
      text-align: center;
      margin-top: 68px !important; /* Use margin to position it vertically */
      }

      
      .correct-order-tile {
      font-weight: 650 !important;
      position: relative;
      top: -135px !important;             /* Adjust vertical position as needed */
      transition: transform 0.3s ease;
      z-index: 1;             /* Ensure it's on top of other elements */
    }


    
    #itemListWrapper {
    position: absolute;  /* Use absolute positioning to ensure it is centered */
    top: 60px;
    left: 50%;
    transform: translateX(-50%);  /* Center the element */
    width: 90%;  /* Ensure it doesn't stretch beyond the screen width */
    z-index: 10;  /* Ensure it's above other content */
    box-sizing: border-box;  /* Prevent padding/margins from affecting width */
    will-change: transform; /* Optimize for mobile */
  }








  #endGameStatus {
      font-size: 3.5rem !important; /* Adjust this size as needed for mobile */
      font-family: 'second' !important;
      /*font-weight: bold;*/
      color: #000;
      text-align: center;
      margin-top: 9px !important;
    }

      #finalScore {
        margin-top: -135px !important;
        font-size: 1.2rem !important;
      }

      #thanksMessage {
        
      position: relative;
      top: -130px !important;
      text-align: center;
      font-size: 1.2rem !important;
    }


    #shareLink,
#shareButton {
  position: relative;
  z-index: 1;
  margin-top: 0px !important; /* Keep your margin-top */
}

#shareLink::after,
#shareButton::after {
  content: '';
  position: absolute;
  top: -10px; /* Adjust to expand clickable area vertically */
  left: -10px; /* Adjust to expand clickable area horizontally */
  right: -10px;
  bottom: -10px;
  z-index: -1; /* Invisible expanded clickable area */
}





      

    
  #dateAndRound {
  position: fixed; 
  bottom: 5px !important; /* Lower value pushes it closer to the bottom */
  left: 50%;
  transform: translateX(-50%);
  font-size: .9rem !important;
  
}








/* already played mobile already played mobile already played mobile already played mobile  already played  */





#playedTodayScreen h1 {
  font-size: 2.9rem !important; 
  margin-top: 0px !important;
    }


#playedTodayScreen p {
  padding: 0 20px;
  font-size: 1.3em !important;
  font-weight: bold;
  margin-top: 5px !important;
}

#playedTodayScreen button {
  font-size: 1.4em;
  padding: 10px 22px;
  position: relative;
  z-index: 1;
  margin-top: 90px;
}

#viewStatsButton {
  margin-top: 18px !important;
  display: block !important;
  font-size: 1.4em;
  padding: 10px 22px;
 
}








/* Todays Answers   Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers  Todays Answers */






#playedRoundsAnswers {
  margin-top: 25px;
  display: flex;
  flex-direction: column;
  gap: 45px !important; 
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}

.round-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}


.round-heading {
  font-size: 1.2em;
  margin-bottom: 10px;
}

.round-list {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center; /* This centers the items horizontally */
}


.round-item {
  background: #D8D8D8;
  padding: 8px 12px;
  border-radius: 6px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);

}


/* stats  stats stats stats stats stats stats  stats stats stats stats stats stats  stats stats stats stats stats  */

#statsDisplay {
    margin-top: 80px !important;
    padding: 12px;
    font-size: 25px;
  } 



/* stats  stats stats stats stats stats stats  stats stats stats stats stats stats  stats stats stats stats stats  */

 
}




    /* GIF */
    .mobile-logo {
      margin-top: 22px !important;
      width: 200px; /* Default size */
      height: 100px; /* Default size */
      margin-left: 11px;
      
}



#gameStatus {
  display: block !important;
}




  </style>
</head>
<body>
 
</body>




<div id="playedTodayScreen" class="hidden">
  <img src="movingLogo.gif" alt="Moving Logo" class="mobile-logo">
  <h1>Order It.</h1>
  <p>You've already played today! Check back tomorrow!</p>
  <button onclick="showAnswers()">Today's Answers</button>
  <button id="viewStatsButton">My Stats</button>
</div>


<div id="statsDisplay" class="hidden" style="margin-top: 10px;"></div>
<div id="gamesPlayedStat"></div>


<div id="answersScreen" class="hidden">
  <div id="playedRoundsAnswers"></div>
</div>




  <div id="welcomeScreen">
    <div>

      <img src="movingLogo.gif" alt="Moving Logo" class="mobile-logo">



      <h1>Order It.</h1>
      <p>Drag the items into the correct order based on the given category. The item with the lowest value (smallest, shortest, lightest, etc.) should go at the top. 
        The item with the highest value (largest, tallest, heaviest, etc.) should go at the bottom. 3 rounds. 3 mistakes allowed.</p>
      <button onclick="startGame()">Play</button>
    </div>
  </div>





  <div id="gameScreen" class="hidden">
    <h2 id="roundPrompt"></h2>
    <p id="gameStatus"></p>

    <div id="itemListWrapper">
    <ul id="itemList"></ul>
  </div>
    <p id="strikeCount"></p>
    

    <div id="submitWrapper"> 
      <div class="touch-buffer">
        <button onclick="submitOrder()">Submit</button>
      </div>
    </div>
  </div>
  
  <div id="endScreen" class="hidden">
    <p id="endGameStatus"></p>
    <p id="finalScore"></p> 
    <p id="thanksMessage">Thanks for playing. Come back tomorrow for a new Order It!</p>
    <button id="shareButton">Share Your Score</button> 
    <p id="shareLink" style="word-break: normal; font-size: 1.2em; margin-top: 10px;"></p>

  </div>
  
  <p id="dateAndRound"></p>

  
  <script>
    let currentRound = 0;
    let rounds = [];
    let strikes = 0;
    const maxStrikes = 3;










const LAUNCH_DATE = new Date(2025, 4, 10); 
const now = new Date();
const localToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
const msPerDay = 1000 * 60 * 60 * 24;

const dayIndex = Math.floor((localToday - LAUNCH_DATE) / msPerDay);

function startGame() {
  const todayString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
  const lastPlayed = localStorage.getItem('lastPlayedDate');

  // Check if the user has already played today
  if (lastPlayed === todayString) {
    showPlayedTodayScreen();
    return;
  }

  // If not, proceed with starting the game
  fetch("rounds.json")
    .then(res => res.json())
    .then(data => {
      rounds = data.days[dayIndex]; // Get the round for today

      const savedStrikes = parseInt(localStorage.getItem('currentStrikes')) || 0;
      const savedRound = parseInt(localStorage.getItem('currentRound')) || 0;

      strikes = savedStrikes;
      currentRound = savedRound;

      document.getElementById('welcomeScreen').classList.add('hidden');
      const gameScreen = document.getElementById('gameScreen');
      gameScreen.classList.remove('hidden');
      requestAnimationFrame(() => {
        gameScreen.classList.add('visible');
      });

      loadRound();

      
      
    })
    .catch(error => {
      console.error("Error loading rounds data:", error);
    });
}

















function displayDateAndRound() {
  const now = new Date();
  const options = { year: 'numeric', month: 'long', day: 'numeric' };
  const formattedDate = now.toLocaleDateString(undefined, options);
  const roundNumber = dayIndex + 1;
  document.getElementById('dateAndRound').textContent = `${formattedDate} — # ${roundNumber}`;
}

// Call the function
displayDateAndRound();

  






    

    function loadRound() {
  if (currentRound >= rounds.length) {
    endGame();
    return;
  }

  const { prompt, items } = rounds[currentRound];
  document.getElementById('roundPrompt').textContent = "Order by: " + prompt;

  const itemList = document.getElementById('itemList');
  itemList.innerHTML = ''; // Always clear old items

  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    li.setAttribute('draggable', true);
    li.classList.add('draggable-item');
    itemList.appendChild(li);
  });

  updateStrikes();
  makeItemsDraggable();
}









function showPlayedTodayScreen() {
  document.getElementById('welcomeScreen').classList.add('hidden');
  document.getElementById('gameScreen').classList.add('hidden');
  document.getElementById('endScreen').classList.add('hidden');
  document.getElementById('answersScreen').classList.add('hidden');
  document.getElementById('playedTodayScreen').classList.remove('hidden');

  const roundsContainer = document.getElementById('playedRounds');
  roundsContainer.innerHTML = '';

  rounds.forEach((round) => {
    const section = document.createElement('div');
    section.classList.add('round-section');

    const heading = document.createElement('h3');
    heading.classList.add('round-heading');
    heading.textContent = round.prompt;

    const listContainer = document.createElement('div');
    listContainer.classList.add('round-list');

    round.correctOrder.forEach((item) => {
      const itemDiv = document.createElement('div');
      itemDiv.classList.add('round-item');
      itemDiv.textContent = item;
      listContainer.appendChild(itemDiv);
    });

    section.appendChild(heading);
    section.appendChild(listContainer);
    roundsContainer.appendChild(section);
  });
}







function showAnswers() {
  document.getElementById('playedTodayScreen').style.display = 'none';
  document.getElementById('answersScreen').classList.remove('hidden');
  document.getElementById('dateAndRound').style.display = 'none';
}




function showAnswers() {
  document.getElementById('playedTodayScreen').style.display = 'none'; 
  document.getElementById('answersScreen').classList.remove('hidden');
  document.getElementById('dateAndRound').style.display = 'none';

  // Clear any previous data
  const roundsContainer = document.getElementById('playedRoundsAnswers');
  roundsContainer.innerHTML = '';

  // Display the rounds data for today
  fetch("rounds.json")
    .then(res => res.json())
    .then(data => {
      const todaysRounds = data.days[dayIndex]; // Use `dayIndex` to get today's rounds

      todaysRounds.forEach((round) => {
        const section = document.createElement('div');
        section.classList.add('round-section');

        const heading = document.createElement('h3');
        heading.classList.add('round-heading');
        heading.textContent = round.prompt; // Add the prompt for the category

        const listContainer = document.createElement('div');
        listContainer.classList.add('round-list');

        // Display the correct order of items for this round
        round.correctOrder.forEach((item) => {
          const itemDiv = document.createElement('div');
          itemDiv.classList.add('round-item');
          itemDiv.textContent = item;
          listContainer.appendChild(itemDiv);
        });

        section.appendChild(heading);
        section.appendChild(listContainer);
        roundsContainer.appendChild(section);
      });
    })
    .catch(error => {
      console.error("Error loading rounds data for answers:", error);
    });
}




    document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    // Force a repaint to clear GPU artifacts
    document.body.style.transform = 'translateZ(0)';
    setTimeout(() => {
      document.body.style.transform = '';
    }, 50);
  }
});










  function makeItemsDraggable() {
  let hasMoved = false;

  const items = document.querySelectorAll('.draggable-item');
  let draggedItem = null;
  let draggedItemInitialPosition = { x: 0, y: 0 };
  let offsetX = 0;
  let offsetY = 0;

  // Desktop drag & drop
  items.forEach(item => {
    item.setAttribute('draggable', true);

    item.addEventListener('dragstart', (e) => {
      draggedItem = item;
      draggedItem.classList.add('dragging');
      setTimeout(() => {
        draggedItem.style.opacity = '0.5';
      }, 0);
    });

    item.addEventListener('dragend', () => {
      draggedItem.style.opacity = '';
      draggedItem.classList.remove('dragging');
      draggedItem = null;
    });

    item.addEventListener('dragover', (e) => e.preventDefault());
    item.addEventListener('dragenter', (e) => e.preventDefault());

    item.addEventListener('drop', () => {
      if (draggedItem && draggedItem !== item) {
        const list = item.parentNode;
        const draggedIndex = Array.from(list.children).indexOf(draggedItem);
        const targetIndex = Array.from(list.children).indexOf(item);

        if (draggedIndex < targetIndex) {
          list.insertBefore(draggedItem, item.nextSibling);
        } else {
          list.insertBefore(draggedItem, item);
        }
      }
    });
  });

  // Mobile touch
  items.forEach(item => {
    item.addEventListener('touchstart', (e) => {
      hasMoved = false;

      e.preventDefault();
      draggedItem = item;
      draggedItemInitialPosition = {
        x: e.touches[0].pageX,
        y: e.touches[0].pageY
      };
      draggedItem.classList.add('dragging');
      draggedItem.style.transition = 'none';
      draggedItem.style.zIndex = '1000';
      draggedItem.style.opacity = '0.5';
    });

    item.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
const dx = touch.pageX - draggedItemInitialPosition.x;
const dy = touch.pageY - draggedItemInitialPosition.y;

if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
  hasMoved = true;
}

      
      offsetX = touch.pageX - draggedItemInitialPosition.x;
      offsetY = touch.pageY - draggedItemInitialPosition.y;
      draggedItem.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    });






item.addEventListener('touchend', (e) => {
  // Reset visuals

  if (!hasMoved) {
  // It's a tap, not a drag — just reset and exit
  draggedItem.classList.remove('dragging');
  draggedItem.style.transform = '';
  draggedItem.style.transition = '';
  draggedItem.style.opacity = '';
  draggedItem.style.zIndex = '';
  draggedItem = null;
  return;
}

  draggedItem.style.transform = '';
  draggedItem.style.transition = '';
  draggedItem.style.opacity = '';
  draggedItem.style.zIndex = '';

  const touch = e.changedTouches[0];
  const list = draggedItem.parentNode;
  const itemsArray = Array.from(list.children);

  let targetItem = null;

  // Start scan from 0 to ±50px to prioritize closest elements
  const scanOffsets = [];
  for (let i = 0; i <= 50; i += 5) {
    scanOffsets.push(i, -i); // [0, -0, 5, -5, 10, -10, ...]
  }

  for (const offset of scanOffsets) {
    // Temporarily hide draggedItem for detection
    draggedItem.style.visibility = 'hidden';
    const el = document.elementFromPoint(touch.clientX, touch.clientY + offset);
    draggedItem.style.visibility = 'visible';

    if (!el) continue;
    const candidate = el.closest('.draggable-item');
    if (candidate && candidate !== draggedItem) {
      targetItem = candidate;
      break;
    }
  }

  if (targetItem) {
  const targetRect = targetItem.getBoundingClientRect();
  const targetCenterY = targetRect.top + targetRect.height / 2;

  if (touch.clientY > targetCenterY) {
    list.insertBefore(draggedItem, targetItem.nextSibling); // drop after
  } else {
    list.insertBefore(draggedItem, targetItem); // drop before
  }
}


  draggedItem.classList.remove('dragging');
  draggedItem = null;
});


  });
}










let roundsCompleted = 0; // Track how many rounds the player has completed successfully.

function submitOrder() {
  const itemList = document.getElementById('itemList');
  const submittedOrder = Array.from(itemList.children).map(li => li.textContent);
  const correctOrder = rounds[currentRound].correctOrder;

  if (JSON.stringify(submittedOrder) === JSON.stringify(correctOrder)) {
    roundsCompleted++; // Increment rounds completed on correct order.
    currentRound++;
    localStorage.setItem('currentRound', currentRound);
    localStorage.setItem('currentStrikes', strikes);


    itemList.classList.add('correct-animation'); // Add the animation class

    // Remove the animation class after 600ms (duration of animation)
    setTimeout(() => {
      itemList.classList.remove('correct-animation');
    }, 900); 

    if (currentRound < rounds.length) {
      loadRound();
    } else {
      // If all rounds are completed without exceeding max strikes
      if (strikes < maxStrikes) {
        setTimeout(() => {
          endGame(); // Wait for a moment, then end the game
          markGameAsPlayed(); // Mark the game as played after it ends
        }, 500);
      } else {
        document.getElementById('gameStatus').textContent = "Nice!"; // Fallback message if there are strikes
        setTimeout(() => {
          endGame(); // End the game with strikes
          markGameAsPlayed(); // Mark the game as played after it ends
        }, 500);
      }
    }
  } else {
    strikes++;
    localStorage.setItem('currentStrikes', strikes);
    updateStrikes(); // Update the strikes count

  









const itemList = document.getElementById('itemList');
itemList.classList.add('shake');


itemList.offsetHeight;  


setTimeout(() => {
  itemList.classList.remove('shake');
}, 400);


    if (strikes >= maxStrikes) {
      const strikeCountEl = document.getElementById('strikeCount'); // This is the element showing "Mistakes Remaining"
      if (strikeCountEl) {
        strikeCountEl.style.display = 'none'; // This hides the text element
      }


      const itemList = document.getElementById('itemList');
      itemList.innerHTML = '';

      // Create the label and add the class instead of inline styles
      const label = document.createElement('p');
      label.textContent = 'Correct Order:';
      label.classList.add('correct-order-label');  // Add the CSS class here



      itemList.parentNode.insertBefore(label, itemList);

      correctOrder.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        li.classList.add('draggable-item');
        li.classList.add('correct-order-tile');
        li.style.backgroundColor = '#A8A8A8';
        li.style.fontWeight = 'bold';
        li.style.cursor = 'default';
        li.setAttribute('draggable', false);
        itemList.appendChild(li);
      });

      document.querySelector("button[onclick='submitOrder()']").disabled = true;
      document.getElementById("submitWrapper").style.display = "none";


      setTimeout(() => {
        label.remove();
        endGame();
      }, 5000);
    }
  }
}


  
    function updateStrikes() {
      document.getElementById('strikeCount').textContent = `Mistakes Remaining: ${maxStrikes - strikes}`;

    }




    
  let score = 0; // you should already be tracking this
   


  function endGame() {
  markGameAsPlayed();

  const now = new Date();
  const todayString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
  localStorage.setItem('lastPlayedDate', todayString);



  console.log("End game triggered");  // Test if this is being reached
  document.getElementById('gameScreen').classList.add('hidden'); // Hide the game screen
  document.getElementById('endScreen').classList.remove('hidden'); // Show the end screen

  let message = "";  // Default message

  // Set message based on the rounds completed
  if (roundsCompleted === 3) {
    message = "Amazing!";
  } else if (roundsCompleted === 2) {
    message = "Good job!";
  } else if (roundsCompleted === 1) {
    message = "Not bad!";
  } else {
    message = "Nice try";
  }

  
  document.getElementById('endGameStatus').textContent = message;

  
  document.getElementById('finalScore').textContent = `You scored ${roundsCompleted} out of ${rounds.length}`;

 
  const shareButton = document.getElementById('shareButton');

  localStorage.removeItem('currentStrikes');
  localStorage.removeItem('currentRound');

  updateStats(roundsCompleted);
 
}



function generateShareLink(roundsCompleted) {
  // Get the emoji score based on the rounds completed
  const emojiScore = getEmojiScore(roundsCompleted);

  // Create the shareable URL with the emoji score as a query parameter
  const baseUrl = window.location.origin + window.location.pathname; // Current page URL
  const shareUrl = `${baseUrl}?score=${emojiScore}`;

  // Set the inner HTML of the shareLink element to show the link with emoji score
  const shareLink = document.getElementById('shareLink');
  shareLink.innerHTML = `<a href="${shareUrl}" target="_blank">Order It ${emojiScore}</a>`;
}



function getEmojiScore(roundsCompleted) {
  const maxRounds = 3; 
  let score = '';

  if (roundsCompleted == 0) {
    score = '⬛⬛⬛'; 
  } else if (roundsCompleted == 1) {
    score = '🟩⬛⬛'; 
  } else if (roundsCompleted == 2) {
    score = '🟩🟩⬛'; 
  } else if (roundsCompleted == 3) {
    score = '🟩🟩🟩'; 
  }

  return score;
}



const shareButton = document.getElementById('shareButton');

shareButton.addEventListener('click', () => {

  
  // Use the getEmojiScore function to get the emoji score
  const emojiScore = getEmojiScore(roundsCompleted);
  
  
  const correctCount = roundsCompleted; // Assuming `roundsCompleted` equals the number of correct answers
  const total = 3; // This can be dynamic if the total number of rounds is variable

  let text; // Declare `text` here

  if (roundsCompleted == 3) {
  if (strikes == 1) {
    text = `${emojiScore}\n${roundsCompleted}/3 rounds\n${strikes} mistake`;
  } else {
    text = `${emojiScore}\n${roundsCompleted}/3 rounds\n${strikes} mistakes`;
  }
} else {
  text = `${emojiScore}`;
}




  const shareData = {
    title: 'Order It',
    text: text,
    url: window.location.href
  };

  // Trigger the share functionality (this depends on your environment, e.g., for web sharing)
  if (navigator.share) {
    navigator.share(shareData)
      .then(() => console.log('Share successful!'))
      .catch((error) => console.log('Error sharing:', error));
  } else {
    // Fallback if Web Share API is not supported
    console.log('Web Share API not supported. Sharing manually via text:');
    console.log(text);
  }
}
);















function updateStats(roundsCompleted) {
  const stats = JSON.parse(localStorage.getItem("orderItStats")) || {
    gamesPlayed: 0,
    rounds0: 0,
    rounds1: 0,
    rounds2: 0,
    rounds3: 0
  };

  const key = `rounds${roundsCompleted}`;
  if (stats[key] !== undefined) {
    stats[key]++;
  }

  // Increment games played
  stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;

  localStorage.setItem("orderItStats", JSON.stringify(stats));
}



document.getElementById('viewStatsButton').addEventListener('click', () => {
  console.log("Stats button clicked");

  // Hide all other screens
  document.getElementById('playedTodayScreen').classList.add('hidden');
  document.getElementById('answersScreen').classList.add('hidden');

  // Load stats and ensure all expected keys exist
  const stats = JSON.parse(localStorage.getItem("orderItStats")) || {};
  stats.gamesPlayed = stats.gamesPlayed || 0;
  stats.rounds0 = stats.rounds0 || 0;
  stats.rounds1 = stats.rounds1 || 0;
  stats.rounds2 = stats.rounds2 || 0;
  stats.rounds3 = stats.rounds3 || 0;

  const statsText = `
  <div style="font-family: sans-serif; color: #111; max-width: 300px; margin: auto;">
<h2 style="text-align: center; margin: 0 0 60px 0; font-size: 70; font-family: 'second';">My Stats</h2>
<p style="text-align: center; margin: 0 0 100px 0; font-size: 50; font-family: 'Lora';"><strong>Games Played:</strong> ${stats.gamesPlayed}</p>


    <table style="width: 100%; border-spacing: 0 10px; font-family: 'Lora';">
      <thead>
        <tr>
          <th style="text-align: left; font-size: 20px;">Rounds Completed</th>
          <th style="text-align: right; font-size: 20px;">Count</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>3 Rounds</td><td style="text-align: right;">${stats.rounds3}</td></tr>
        <tr><td>2 Rounds</td><td style="text-align: right;">${stats.rounds2}</td></tr>
        <tr><td>1 Round</td><td style="text-align: right;">${stats.rounds1}</td></tr>
        <tr><td>0 Rounds</td><td style="text-align: right;">${stats.rounds0}</td></tr>
      </tbody>
    </table>
  </div>
`;


  const statsDisplay = document.getElementById('statsDisplay');
  document.getElementById('dateAndRound').style.display = 'none';
  statsDisplay.innerHTML = statsText;
  statsDisplay.classList.remove('hidden');
});















function markGameAsPlayed() {
  const today = new Date().toISOString().split('T')[0];
  localStorage.setItem('lastPlayedDate', today);
  console.log('Saved lastPlayedDate as', today); 

  let gamesPlayed = parseInt(localStorage.getItem('gamesPlayed')) || 0;
  gamesPlayed += 1;
  localStorage.setItem('gamesPlayed', gamesPlayed);

}




function alreadyPlayedToday() {
  const today = new Date().toISOString().split('T')[0]; 
  const lastPlayed = localStorage.getItem('lastPlayedDate');
  return lastPlayed === today;
}



window.onload = function() {
  if (alreadyPlayedToday()) {
    showPlayedTodayScreen();
  } else {
    document.getElementById('welcomeScreen').style.display = 'block';
  }
};


window.addEventListener('DOMContentLoaded', () => {
  const now = new Date();
  const todayString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
  const lastPlayed = localStorage.getItem('lastPlayedDate');

  if (lastPlayed === todayString) {
    // User has already played today
    fetch("rounds.json")
      .then(res => res.json())
      .then(data => {
        rounds = data.days[dayIndex]; // Set today's rounds for display
        showPlayedTodayScreen(); // Show the correct screen immediately
      })
      .catch(error => {
        console.error("Error loading rounds data for already played screen:", error);
      });
  }
});




   

  </script>

</body>
</html>
